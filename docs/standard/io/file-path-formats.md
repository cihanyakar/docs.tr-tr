---
title: Windows sistemlerde dosya yolu biçimleri
ms.date: 06/28/2018
ms.technology: dotnet-standard
ms.topic: article
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 05146467f321a3c83f3637e2eecc4c7c42dc4ba0
ms.sourcegitcommit: 3b1cb8467bd73dee854b604e306c0e7e3882d91a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/06/2018
ms.locfileid: "51214200"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="6c7c2-102">Windows sistemlerde dosya yolu biçimleri</span><span class="sxs-lookup"><span data-stu-id="6c7c2-102">File path formats on Windows systems</span></span>

<span data-ttu-id="6c7c2-103">Çoğu içindeki türlerin üyelerini <xref:System.IO> ad alanı içeren bir `path` mutlak veya göreli bir yol için bir dosya sistemi kaynak belirtmenize olanak sağlar. parametre.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-103">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="6c7c2-104">Bu yolu geçirilerek [Windows dosya sistemi API'ları](https://msdn.microsoft.com/library/windows/desktop/aa364407(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-104">This path is then passed to [Windows file system APIs](https://msdn.microsoft.com/library/windows/desktop/aa364407(v=vs.85).aspx).</span></span> <span data-ttu-id="6c7c2-105">Bu konuda Windows sistemlerinde kullanabilirsiniz dosya yolları için biçimleri açıklanır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-105">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="6c7c2-106">Geleneksel DOS yolları</span><span class="sxs-lookup"><span data-stu-id="6c7c2-106">Traditional DOS paths</span></span>

<span data-ttu-id="6c7c2-107">Standart bir DOS yol üç bileşeni oluşabilir:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-107">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="6c7c2-108">Bir birim veya sürücü harfini izleyen tarafından toplu ayırıcı (`:`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-108">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="6c7c2-109">Bir dizin adı.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-109">A directory name.</span></span> <span data-ttu-id="6c7c2-110">[Dizin ayırıcı karakterde](<xref:System.IO.Path.DirectorySeparatorChar>) iç içe geçmiş dizin sıradüzeni içinde alt dizinler ayırır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-110">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="6c7c2-111">İsteğe bağlı bir dosya adı.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-111">An optional filename.</span></span> <span data-ttu-id="6c7c2-112">[Dizin ayırıcı karakterde](<xref:System.IO.Path.DirectorySeparatorChar>) dosya yolu ve dosya adını ayırır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-112">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="6c7c2-113">Üç bileşen mevcut olması durumunda, mutlak bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-113">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="6c7c2-114">Birim veya sürücü harfi yok belirtilirse ve dizin adları ile başlayan [dizin ayırıcı karakterde](<xref:System.IO.Path.DirectorySeparatorChar>), geçerli sürücüsünün kökünden göreli yoludur.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-114">If no volume or drive letter is specified and the directory names begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="6c7c2-115">Aksi takdirde, geçerli dizine göreli yoludur.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-115">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="6c7c2-116">Aşağıdaki tabloda, bazı olası dizin ve dosya yolları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-116">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="6c7c2-117">Yol</span><span class="sxs-lookup"><span data-stu-id="6c7c2-117">Path</span></span>  |<span data-ttu-id="6c7c2-118">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6c7c2-118">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="6c7c2-119">C: sürücüsünün kökünden bir mutlak dosya yolu</span><span class="sxs-lookup"><span data-stu-id="6c7c2-119">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="6c7c2-120">Geçerli sürücüsünün kökünden mutlak bir yol.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-120">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="6c7c2-121">Geçerli dizininin bir alt dosyaya göreli yol.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-121">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="6c7c2-122">Geçerli dizin eşdüzeyde bir dizindeki dosya için göreli bir yol.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-122">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="6c7c2-123">Bir dosya için mutlak bir yol C: sürücüsünün kökünden</span><span class="sxs-lookup"><span data-stu-id="6c7c2-123">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="6c7c2-124">Geçerli dizininden C: sürücüsünün göreli bir yol.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-124">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="6c7c2-125">Son iki yolu arasındaki farka dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-125">Note the difference between the last two paths.</span></span> <span data-ttu-id="6c7c2-126">Hem isteğe bağlı bir birim tanımlayıcısı (her iki durumda da C:) belirtin, ancak ikinci desteklemez ilk belirtilen birimin kökündeki ile başlar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-126">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="6c7c2-127">Sonuç olarak, ikinci bir göreli yol geçerli dizininden C: sürücüsünün bilgileriyse mutlak bir yol kök dizininden C: sürücüsünün davranıştır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-127">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="6c7c2-128">Windows dosya yolları ilgili hatalar ortak bir kaynağı ilk istendiğinde ikinci formu kullanın.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-128">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="6c7c2-129">Bir dosya yolu tam olup olmadığını belirleyebilir (diğer bir deyişle, bu yolun geçerli dizine bağımsızdır ve geçerli dizine değiştiğinde değiştirmez) çağırarak <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-129">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="6c7c2-130">Böyle bir yol göreli directory parçaları dahil edebileceğinizi unutmayın (`.` ve `..`) ve çözümlenen yol her zaman aynı konuma işaret ediyorsa yine de tam olarak nitelenmiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-130">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="6c7c2-131">Aşağıdaki örnek, mutlak ve göreli yolları arasındaki farkı gösterir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-131">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="6c7c2-132">D:\FY2018\ dizinin var olduğundan ve, herhangi bir geçerli dizin için D:\ Komut İstemi'nden örneği çalıştırmadan önce ayarlamasını yapmadığınızı fark olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-132">It assumes that the directory D:\FY2018\ exists, and that you haven't set any curent directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

## <a name="unc-paths"></a><span data-ttu-id="6c7c2-133">UNC yolu</span><span class="sxs-lookup"><span data-stu-id="6c7c2-133">UNC paths</span></span>

<span data-ttu-id="6c7c2-134">Ağ kaynaklarına erişmek için kullanılan, Evrensel Adlandırma Kuralı (UNC) yollarını, aşağıdaki biçime sahiptir:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-134">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="6c7c2-135">Tarafından başında bir sunucu veya ana bilgisayar adı \\ \\.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-135">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="6c7c2-136">Sunucu adı, NetBIOS makine adı veya IP/FQDN adresi (IPv4 v6 desteklenir gibi iyi) olabilir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-136">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="6c7c2-137">Ana bilgisayar adına göre ayrılmış olan bir paylaşım adı \\.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-137">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="6c7c2-138">Birlikte, sunucu ve Paylaşım adı birimi yavaşça olun.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-138">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="6c7c2-139">Bir dizin adı.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-139">A directory name.</span></span> <span data-ttu-id="6c7c2-140">[Dizin ayırıcı karakterde](<xref:System.IO.Path.DirectorySeparatorChar>) iç içe geçmiş dizin sıradüzeni içinde alt dizinler ayırır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-140">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="6c7c2-141">İsteğe bağlı bir dosya adı.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-141">An optional filename.</span></span> <span data-ttu-id="6c7c2-142">[Dizin ayırıcı karakterde](<xref:System.IO.Path.DirectorySeparatorChar>) dosya yolu ve dosya adını ayırır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-142">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="6c7c2-143">UNC yolu bazı örnekleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-143">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="6c7c2-144">Yol</span><span class="sxs-lookup"><span data-stu-id="6c7c2-144">Path</span></span>  |<span data-ttu-id="6c7c2-145">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6c7c2-145">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="6c7c2-146">C: kök dizinine sürücü üzerinde `system07`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-146">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="6c7c2-147">Test dizini Foo.txt dosyasında \\ \\Sunucu2\\birim paylaşın.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-147">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="6c7c2-148">UNC yollarını her zaman tam olarak nitelenmiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-148">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="6c7c2-149">Göreli directory parçaları dahil edebilirsiniz (`.` ve `..`), ancak bunlar tam nitelenmiş bir yol bir parçası olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-149">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="6c7c2-150">Göreli yollar yalnızca bir UNC yolu bir sürücü harfi ile eşleştirerek kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-150">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="6c7c2-151">DOS cihaz yolları</span><span class="sxs-lookup"><span data-stu-id="6c7c2-151">DOS device paths</span></span>

<span data-ttu-id="6c7c2-152">Windows işletim sistemi dosyaları dahil tüm kaynakları işaret eden bir birleşik nesne modeline sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-152">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="6c7c2-153">Bu nesne yolları konsol penceresinden erişebilir ve Win32 katmana eski DOS ve UNC yollarını eşlendiğine simgesel bağlantıların özel bir klasör aracılığıyla sunulur.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-153">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="6c7c2-154">Bu özel klasör olan DOS aygıtı yolu sözdizimi erişilen biri:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-154">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`  
`\\?\C:\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="6c7c2-155">DOS aygıtı yolu sözdizimi .NET Framework 4.6.2 ve .NET Core 1.1 ile başlayarak Windows üzerinde çalışan .NET uygulamalarında desteklenir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-155">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="6c7c2-156">DOS aygıtı yolu aşağıdaki bileşenlerden oluşur:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-156">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="6c7c2-157">Cihaz yolu tanımlayıcısı (`\\.\` veya `\\?\`), yolun bir DOS aygıtı yol olarak tanımlar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-157">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="6c7c2-158">`\\?\` Tüm sürümlerinde .NET Core ve .NET Framework 4.6.2 sürümünden itibaren desteklenir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-158">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>
   
- <span data-ttu-id="6c7c2-159">Sembolik bağlantıyı "gerçek" cihaz nesnesine (Bu durumda C:).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-159">A symbolic link to the "real" device object (C: in this case).</span></span>

   <span data-ttu-id="6c7c2-160">İlk cihaz yolu tanımlayıcısı sonraki DOS aygıtı yol kesimi toplu veya sürücü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-160">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="6c7c2-161">(Örneğin, `\\?\C:\` ve `\\.\BootPartition\`.)</span><span class="sxs-lookup"><span data-stu-id="6c7c2-161">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="6c7c2-162">Edilebileceği çağrılır belirli bir bağlantı için UNC `UNC`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-162">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="6c7c2-163">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-163">For example:</span></span>

      `\\.\UNC\Server\Share\Test\Foo.txt`
      `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="6c7c2-164">Cihaz UNC paylaşımı/bölümü forms olan birim.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-164">For device UNCs, the server/share portion is forms the volume.</span></span> <span data-ttu-id="6c7c2-165">Örneğin, `\\?\server1\e:\utilities\\filecomparer\`, server1\utilities paylaşımı/bölümüdür.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-165">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="6c7c2-166">Bir yöntemi gibi çağrılırken bu önemlidir <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> göreli directory bölümleri ile; hiçbir zaman birimi gitmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-166">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span> 

<span data-ttu-id="6c7c2-167">DOS cihaz yolları tanımına göre tam.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-167">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="6c7c2-168">Göreli directory parçaları (`.` ve `..`) izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-168">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="6c7c2-169">Geçerli dizin, hiçbir zaman kendi kullanımlarına girin.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-169">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="6c7c2-170">Örnek: aynı dosyaya başvurmak için yollar</span><span class="sxs-lookup"><span data-stu-id="6c7c2-170">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="6c7c2-171">Aşağıdaki örnek, başvurabilirsiniz bir dosyaya API'leri kullanırken yollardan bazılarını göstermektedir <xref:System.IO> ad alanı.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-171">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="6c7c2-172">Örnek bir <xref:System.IO.FileInfo> nesne ve kullanımları onun <xref:System.IO.FileInfo.Name> ve <xref:System.IO.FileInfo.Length> dosya adı ve dosya uzunluğunu görüntülemek için özellikler.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-172">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="6c7c2-173">Yol normalleştirme</span><span class="sxs-lookup"><span data-stu-id="6c7c2-173">Path normalization</span></span>

<span data-ttu-id="6c7c2-174">Neredeyse tüm yolları Windows API'lerine geçirilen normalleştirilir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-174">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="6c7c2-175">Normalleştirme sırasında Windows aşağıdaki adımları gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-175">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="6c7c2-176">Yolunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-176">Identifies the path.</span></span>
- <span data-ttu-id="6c7c2-177">Geçerli dizin kısmen nitelenmiş (göreli) yollara uygular.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-177">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="6c7c2-178">Bileşen ve dizin ayırıcı canonicalizes.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-178">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="6c7c2-179">Göreli dizini bileşenlerini değerlendirir (`.` geçerli dizin için ve `..` üst dizini için).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-179">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="6c7c2-180">Belirli karakterlerin kırpar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-180">Trims certain characters.</span></span>

<span data-ttu-id="6c7c2-181">Bu normalleştirme örtük olarak gerçekleşir, ancak bunu açıkça çağırarak yapabilirsiniz <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> yöntemine bir çağrı sarılır [GetFullPathName() işlevi](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).aspx).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-181">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).aspx).</span></span> <span data-ttu-id="6c7c2-182">Windows de çağırabilirsiniz [GetFullPathName() işlevi](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).aspx) kullanarak doğrudan P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-182">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).aspx) directly using P/Invoke.</span></span> <span data-ttu-id="6c7c2-183">Ayrıca, çağırabilirsiniz</span><span class="sxs-lookup"><span data-stu-id="6c7c2-183">You can also call the</span></span> 

### <a name="identifying-the-path"></a><span data-ttu-id="6c7c2-184">Yolun tanımlama</span><span class="sxs-lookup"><span data-stu-id="6c7c2-184">Identifying the path</span></span>

<span data-ttu-id="6c7c2-185">İlk adımda yolu normalleştirme yol türünü tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-185">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="6c7c2-186">Yolları birkaç kategoriden birine girer:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-186">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="6c7c2-187">Cihaz yolları oldukları; diğer bir deyişle, bunlar iki ayırıcıları ve bir soru işareti veya nokta ile başlayan (`\\?` veya `\\.`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-187">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="6c7c2-188">UNC yollarını oldukları; diğer bir deyişle, bir soru işareti veya dönem olmadan iki ayırıcı ile başlar.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-188">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span> 
- <span data-ttu-id="6c7c2-189">Bunlar tam DOS yollardır; diğer bir deyişle, bunlar bir sürücü harfi, bir birim ayracı ve bileşen ayırıcı ile başlar (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-189">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="6c7c2-190">Bunlar eski bir cihaza atamak (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-190">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="6c7c2-191">Geçerli sürücüsünün köküne göreli oldukları; diğer bir deyişle, bunlar bir tek bileşen ayırıcı ile başlar (`\`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-191">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="6c7c2-192">Belirtilen sürücü geçerli dizine göreli oldukları; diğer bir deyişle, bunlar bir sürücü harfi, bir birim ayracı ve bileşen ayırıcı ile başlar (`C:`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-192">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="6c7c2-193">Geçerli dizinine göreli oldukları; diğer bir deyişle, bunlar başka bir şey ile başlar (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-193">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="6c7c2-194">Yol türü, geçerli bir dizin şekilde uygulanmış olup olmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-194">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="6c7c2-195">Yolun "Kök" ne olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-195">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="6c7c2-196">Eski cihazları işleme</span><span class="sxs-lookup"><span data-stu-id="6c7c2-196">Handling legacy devices</span></span>

<span data-ttu-id="6c7c2-197">Yolun eski bir DOS aygıtı gibi olup olmadığını `CON`, `COM1`, veya `LPT1`, cihaz yola eklenerek dönüştürülür `\\.\` ve döndürülen.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-197">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span> 

<span data-ttu-id="6c7c2-198">Eski cihaz adları ile başlayan yol her zaman eski bir cihaz tarafından yorumlanan <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-198">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6c7c2-199">Örneğin, DOS aygıtı yolunu `CON.TXT` olduğu `\\.\CON`ve DOS aygıtı yolunu `COM1.TXT\file1.txt` olduğu `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-199">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="6c7c2-200">Geçerli dizine uygulanıyor</span><span class="sxs-lookup"><span data-stu-id="6c7c2-200">Applying the current directory</span></span>

<span data-ttu-id="6c7c2-201">Bir yol tam değilse, Windows geçerli dizin için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-201">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="6c7c2-202">UNC ve cihaz yolları uygulanan geçerli dizin yok.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-202">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="6c7c2-203">Tam bir sürücü C: ayırıcısıyla diğerinden mu\\.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-203">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="6c7c2-204">Yolun bir tek bileşen ayırıcı ile başlarsa, geçerli dizin sürücüden uygulanır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-204">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="6c7c2-205">Örneğin, dosya yolu ise `\utilities` ve geçerli dizin `C:\temp\`, normalleştirme üretir `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-205">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="6c7c2-206">Yolun bir sürücü harfi, birim ayırıcı ve bileşen ayırıcı ile başlarsa, komut kabuğundan belirtilen sürücü için ayarlanmış son geçerli dizine uygulanır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-206">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="6c7c2-207">Son geçerli dizin ayarlanmadı, tek başına sürücü uygulanır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-207">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="6c7c2-208">Örneğin, dosya yolu ise `D:sources`, geçerli dizin `C:\Documents\`, ve D: sürücüsü son geçerli dizinde `D:\sources\`, sonuç `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-208">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="6c7c2-209">Bu "göreli sürücü" yolları program ve betik mantık hataları ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-209">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="6c7c2-210">Bir harf ve bir iki nokta üst üste ile başlayan yol göreli değil varsayarak açıkça doğru değil.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-210">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="6c7c2-211">Yol ayırıcı dışında bir şey ile başlarsa, geçerli bir sürücü ve geçerli dizinde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-211">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="6c7c2-212">Örneğin, yol ise `filecompare` ve geçerli dizin `C:\utilities\`, sonuç `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-212">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6c7c2-213">İşlem içi ayarı geçerli dizin olduğu için göreli yolların tehlikeli birden çok iş parçacıklı uygulamalar (diğer bir deyişle, çoğu uygulamalar).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-213">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="6c7c2-214">Herhangi bir iş parçacığı geçerli dizin dilediğiniz zaman değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-214">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="6c7c2-215">.NET Core 2.1 ile başlayarak, çağırabilirsiniz <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> mutlak bir yol göreli bir yol ve karşı çözümlemek istediğiniz temel yolu (geçerli dizin) almak için yöntemi.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-215">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span> 

### <a name="canonicalizing-separators"></a><span data-ttu-id="6c7c2-216">Ayırıcılar standart hale getirme</span><span class="sxs-lookup"><span data-stu-id="6c7c2-216">Canonicalizing separators</span></span>

<span data-ttu-id="6c7c2-217">Tüm İleri eğik çizgi (`/`) standart Windows ayırıcı ters eğik çizgi dönüştürülür (`\`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-217">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="6c7c2-218">Varsa, bir dizi izleyin ilk iki eğik çizgi, eğik çizgi daraltılmış tek bir eğik çizgi.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-218">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="6c7c2-219">Göreli bileşenleri değerlendiriliyor</span><span class="sxs-lookup"><span data-stu-id="6c7c2-219">Evaluating relative components</span></span>

<span data-ttu-id="6c7c2-220">Yolun işlendiğinde, tüm bileşenleri veya tek bir veya iki nokta oluşan parçalarını (`.` veya `..`) değerlendirilir:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-220">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span> 

- <span data-ttu-id="6c7c2-221">Geçerli dizine başvurduğundan tek bir dönem için geçerli kesime kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-221">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="6c7c2-222">İki nokta üst dizine başvurduğundan çift bir dönem için geçerli kesime ve üst segment, kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-222">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="6c7c2-223">Üst dizinlerin, yolun kökü değillerse yalnızca kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-223">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="6c7c2-224">Yol kök yolunun türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-224">The root of the path depends on the type of path.</span></span> <span data-ttu-id="6c7c2-225">Sürücü harfi (`C:\`) DOS yolları, sunucu/paylaşımı için UNC (`\\Server\Share`) ve cihaz yolları cihaz yol ön eki (`\\?\` veya `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-225">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="6c7c2-226">Karakterleri kırpma</span><span class="sxs-lookup"><span data-stu-id="6c7c2-226">Trimming characters</span></span>

<span data-ttu-id="6c7c2-227">Ayırıcılar ve daha önce kaldırılmış göreli kesimleri çalıştırılan yanı sıra bazı ek karakterler normalleştirme sırasında kaldırılır:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-227">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="6c7c2-228">Bir segmenti tek nokta ile bitiyorsa, bu süre kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-228">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="6c7c2-229">(Tek veya çift nokta bir parçası, önceki adımda normalleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-229">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="6c7c2-230">Üç veya daha fazla nokta bir segmentini Normalleştirilmemiş ve aslında bir geçerli dosya/dizin addır.)</span><span class="sxs-lookup"><span data-stu-id="6c7c2-230">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="6c7c2-231">Yolun bir ayırıcı sonlanmıyor, nokta ve boşluk tüm sondaki (U + 0020) kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-231">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="6c7c2-232">Son segmenti yalnızca tek veya çift nokta ise, yukarıdaki göreli bileşenleri kural altında döner.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-232">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span> 

   <span data-ttu-id="6c7c2-233">Bu kural, bir dizin adı boşluk ile sonda ayırıcı sonra boşluk ekleyerek oluşturabileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-233">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>  

   > [!IMPORTANT]
   > <span data-ttu-id="6c7c2-234">Yapmanız gerekenler **hiçbir zaman** bir dizin veya dosya adı, boşluk ile oluşturun.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-234">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="6c7c2-235">Sondaki boşlukları bunu karmaşık hale getirebilir veya erişmek mümkün olmayan bir dizin ve uygulamaları sık dizinleri ve dosyaları, adları boşluk içerir işlemeye çalışırken başarısız.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-235">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="6c7c2-236">Normalleştirme atlanıyor</span><span class="sxs-lookup"><span data-stu-id="6c7c2-236">Skipping normalization</span></span>

<span data-ttu-id="6c7c2-237">Normalde, bir Windows API'ye geçirilen herhangi bir yola (etkin) geçirilen [GetFullPathName işlevi](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) ve normalleştirilmiş.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-237">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="6c7c2-238">Önemli bir istisna vardır: bir dönem yerine bir soru işareti ile başlayan bir cihaz yolu.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-238">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="6c7c2-239">Tam olarak ile başlayan yol sürece `\\?\` (normalleştirilmiş Not kurallı ters eğik çizgi kullanımı).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-239">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="6c7c2-240">Neden normalleştirme atlamak istiyorsunuz?</span><span class="sxs-lookup"><span data-stu-id="6c7c2-240">Why would you want to skip normalization?</span></span> <span data-ttu-id="6c7c2-241">Üç ana nedeni vardır:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-241">There are three major reasons:</span></span>

1. <span data-ttu-id="6c7c2-242">Normalde kullanılamaz ancak yasal yola erişim almak için.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-242">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="6c7c2-243">Bir dosya veya dizin adında `hidden.`, örneğin, herhangi bir şekilde erişmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-243">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span> 

1. <span data-ttu-id="6c7c2-244">Zaten normalleştirilmiş, normalleştirme atlayarak performansını artırmak için.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-244">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="6c7c2-245">.NET Framework ile ilgili atlamak için yalnızca `MAX_PATH` 259 karakterden uzun yollar izin vermek yol uzunluğu olup olmadığını denetleyin.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-245">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="6c7c2-246">Çoğu API'ler, bazı istisnalar izin verir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-246">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="6c7c2-247">.NET core uzun yollar örtük olarak işler ve gerçekleştirmez bir `MAX_PATH` denetleyin.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-247">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="6c7c2-248">`MAX_PATH` Denetim, yalnızca .NET Framework için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-248">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="6c7c2-249">Normalleştirme ve en fazla yol denetimleri atlanıyor iki cihaz yolu sözdizimleri arasındaki tek fark, Aksi takdirde birbirinin aynıdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-249">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="6c7c2-250">Normalleştirme, uğraşmanız "normal" uygulamalar için zor olan yollar kolayca oluşturabilirsiniz olduğundan atlanıyor ile dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-250">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="6c7c2-251">İle başlayan yollar `\\?\` açıkça bunları geçirirseniz hala normalleştirilmiş [GetFullPathName işlevi](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="6c7c2-251">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="6c7c2-252">Yolları için Not birden fazla `MAX_PATH` karakterin [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) olmadan `\\?\`.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-252">Note that you can paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="6c7c2-253">Bu rastgele uzunluktaki yollar Windows işleyebileceği maksimum dize boyutu kadar destekler.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-253">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="6c7c2-254">Windows dosya sistemi ve servis talebi</span><span class="sxs-lookup"><span data-stu-id="6c7c2-254">Case and the Windows file system</span></span>

<span data-ttu-id="6c7c2-255">Windows olmayan kullanıcılara ve geliştiricilere, karmaşık bulma Windows dosya sisteminin bir yaný yoludur ve dizin adları büyük/küçük harfe duyarsızdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-255">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="6c7c2-256">Diğer bir deyişle, dizin ve dosya adları büyük/küçük harf oluşturulduğunda kullanılan dizelerin yansıtır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-256">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="6c7c2-257">Örneğin, yöntem çağrısı</span><span class="sxs-lookup"><span data-stu-id="6c7c2-257">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```
<span data-ttu-id="6c7c2-258">TeStDiReCtOrY adlı bir dizin oluşturur.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-258">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="6c7c2-259">Bir dizin veya dosya kasasının değiştirmek için yeniden adlandırırsanız, dizin veya dosya adı, yeniden adlandırdığınızda kullanılan dize durumunu yansıtır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-259">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="6c7c2-260">Örneğin, aşağıdaki kod, test.txt Test.txt için adlı bir dosyayı yeniden adlandırır:</span><span class="sxs-lookup"><span data-stu-id="6c7c2-260">For example, the following code renames a file named test.txt to Test.txt:</span></span>

```csharp
using System;
using System.IO;

class Example
{
   public static void Main()
   {
      var fi = new FileInfo(@".\test.txt");
      fi.MoveTo(@".\Test.txt");
   }
}
``` 
```vb
Imports System.IO

Module Example
   Public Sub Main()
      Dim fi As New FileInfo(".\test.txt")
      fi.MoveTo(".\Test.txt")
   End Sub
End Module
```

<span data-ttu-id="6c7c2-261">Ancak, dizin ve dosya adı karşılaştırmalar büyük küçük harf duyarlıdır.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-261">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="6c7c2-262">"Test.txt" adlı bir dosya için arama yaparsanız, dosya sistemi API'yi .NET karşılaştırma durumda yoksayın.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-262">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="6c7c2-263">Test.txt, TEST. TXT, test. TXT ve büyük ve küçük harfler, herhangi bir birleşimini "test.txt" eşleşir.</span><span class="sxs-lookup"><span data-stu-id="6c7c2-263">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
