---
title: Normal İfadelerde Geri Dönüş
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 343249f5411d4e5c2335446e7c892b989c8033f2
ms.sourcegitcommit: 35316b768394e56087483cde93f854ba607b63bc
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/26/2018
ms.locfileid: "52297367"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="ef8a1-102">Normal İfadelerde Geri Dönüş</span><span class="sxs-lookup"><span data-stu-id="ef8a1-102">Backtracking in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="ef8a1-103">Geri izlemenin normal ifade deseni isteğe bağlı içerdiğinde gerçekleşir [miktar belirleyiciler](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) veya [değişim yapıları](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), normal ifade altyapısı devam etmek için önceki kaydedilen bir duruma döndürür, bir eşleşme arayın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-103">Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="ef8a1-104">Geri izleme, normal ifadelerin gücü bakımından çok önemlidir; ifadelerin güçlü ve esnek olmasına ve çok karmaşık desenlerle eşleşmelerine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-104">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="ef8a1-105">Aynı zamanda, bu güç bir maliyetle birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-105">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="ef8a1-106">Geri izleme, genellikle normal ifade altyapısının performansını etkileyen tek önemli etmendir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-106">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="ef8a1-107">Neyse ki, geliştirici, normal ifade motorunun davranışını ve geri izlemeyi nasıl kullandığını denetleyebilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-107">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="ef8a1-108">Bu konu, geri izlemenin nasıl çalıştığını ve nasıl kontrol edilebileceğini açıklar.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-108">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ef8a1-109">Genel olarak, .NET normal ifade altyapısı gibi bir belirleyici olmayan sonlu Otomasyon (NFA) altyapısı sorumluluğunu geliştiriciye verimli ve hızlı normal ifadeler kaynaklı yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-109">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  
  
 <span data-ttu-id="ef8a1-110">Bu konu aşağıdaki bölümleri içermektedir:</span><span class="sxs-lookup"><span data-stu-id="ef8a1-110">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="ef8a1-111">Geri izleme olmadan doğrusal karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="ef8a1-111">Linear Comparison Without Backtracking</span></span>](#linear_comparison_without_backtracking)  
  
-   [<span data-ttu-id="ef8a1-112">İsteğe bağlı miktar belirleyiciler veya değişim yapıları ile geri izleme oluşturur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-112">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
-   [<span data-ttu-id="ef8a1-113">İç içe geçmiş isteğe bağlı miktar Belirleyicilerle geri izleme</span><span class="sxs-lookup"><span data-stu-id="ef8a1-113">Backtracking with Nested Optional Quantifiers</span></span>](#backtracking_with_nested_optional_quantifiers)  
  
-   [<span data-ttu-id="ef8a1-114">Geri izlemeyi denetleme</span><span class="sxs-lookup"><span data-stu-id="ef8a1-114">Controlling Backtracking</span></span>](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="ef8a1-115">Geri İzleme Olmadan Doğrusal Karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="ef8a1-115">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="ef8a1-116">Bir normal ifade deseninin isteğe bağlı miktar belirleyicileri yoksa, normal ifade altyapısı doğrusal zamanda çalışır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-116">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="ef8a1-117">Diğer bir deyişle, normal ifade altyapısı desendeki ilk dil öğesini giriş dizesindeki metinle eşleştirdikten sonra, it desende sonraki dil öğesini giriş dizesindeki sonraki karakterle veya karakter grubuyla eşleştirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-117">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="ef8a1-118">Bu, eşleştirme başarılı veya başarısız oluncaya kadar devam eder.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-118">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="ef8a1-119">Her iki durumda da, normal ifade altyapısı giriş dizesinde bir kerede bir karakter ilerler.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-119">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="ef8a1-120">Aşağıdaki örnek, bir gösterim sağlar.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-120">The following example provides an illustration.</span></span> <span data-ttu-id="ef8a1-121">Normal ifade `e{2}\w\b` herhangi bir sözcük karakteri ve ardından "e" harfi iki örneğini arar ve ardından bir sözcük sınırı.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-121">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="ef8a1-122">Bu normal ifade miktar Belirleyicisini içerse de `{2}`, doğrusal bir şekilde değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-122">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="ef8a1-123">Normal ifade altyapısı için geri izleme yapmaz `{2}` bir isteğe bağlı miktar Belirleyicisi; değil bir tam sayı ve olmayan bir değişken sayısı önceki alt ifade ile eşleşmelidir belirtir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-123">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="ef8a1-124">Sonuç olarak, normal ifade altyapısı, aşağıdaki tabloda gösterildiği gibi, normal ifade desenini giriş dizesiyle eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-124">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="ef8a1-125">Çalışma</span><span class="sxs-lookup"><span data-stu-id="ef8a1-125">Operation</span></span>|<span data-ttu-id="ef8a1-126">Desendeki konum</span><span class="sxs-lookup"><span data-stu-id="ef8a1-126">Position in pattern</span></span>|<span data-ttu-id="ef8a1-127">Dizedeki konum</span><span class="sxs-lookup"><span data-stu-id="ef8a1-127">Position in string</span></span>|<span data-ttu-id="ef8a1-128">Sonuç</span><span class="sxs-lookup"><span data-stu-id="ef8a1-128">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="ef8a1-129">1.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-129">1</span></span>|<span data-ttu-id="ef8a1-130">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-130">e</span></span>|<span data-ttu-id="ef8a1-131">"needing a reed" (dizin 0)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-131">"needing a reed" (index 0)</span></span>|<span data-ttu-id="ef8a1-132">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-132">No match.</span></span>|  
|<span data-ttu-id="ef8a1-133">2</span><span class="sxs-lookup"><span data-stu-id="ef8a1-133">2</span></span>|<span data-ttu-id="ef8a1-134">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-134">e</span></span>|<span data-ttu-id="ef8a1-135">"eeding a reed" (dizin 1)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-135">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="ef8a1-136">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-136">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-137">3</span><span class="sxs-lookup"><span data-stu-id="ef8a1-137">3</span></span>|<span data-ttu-id="ef8a1-138">E{2}</span><span class="sxs-lookup"><span data-stu-id="ef8a1-138">e{2}</span></span>|<span data-ttu-id="ef8a1-139">"eding a reed" (dizin 2)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-139">"eding a reed" (index 2)</span></span>|<span data-ttu-id="ef8a1-140">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-140">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-141">4</span><span class="sxs-lookup"><span data-stu-id="ef8a1-141">4</span></span>|<span data-ttu-id="ef8a1-142">\w</span><span class="sxs-lookup"><span data-stu-id="ef8a1-142">\w</span></span>|<span data-ttu-id="ef8a1-143">"al gerekli" (dizin 3)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-143">"ding a reed" (index 3)</span></span>|<span data-ttu-id="ef8a1-144">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-144">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-145">5</span><span class="sxs-lookup"><span data-stu-id="ef8a1-145">5</span></span>|<span data-ttu-id="ef8a1-146">\b</span><span class="sxs-lookup"><span data-stu-id="ef8a1-146">\b</span></span>|<span data-ttu-id="ef8a1-147">"ing a reed" (dizin 4)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-147">"ing a reed" (index 4)</span></span>|<span data-ttu-id="ef8a1-148">Olası eşleşme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-148">Possible match fails.</span></span>|  
|<span data-ttu-id="ef8a1-149">6</span><span class="sxs-lookup"><span data-stu-id="ef8a1-149">6</span></span>|<span data-ttu-id="ef8a1-150">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-150">e</span></span>|<span data-ttu-id="ef8a1-151">"eding a reed" (dizin 2)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-151">"eding a reed" (index 2)</span></span>|<span data-ttu-id="ef8a1-152">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-152">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-153">7</span><span class="sxs-lookup"><span data-stu-id="ef8a1-153">7</span></span>|<span data-ttu-id="ef8a1-154">E{2}</span><span class="sxs-lookup"><span data-stu-id="ef8a1-154">e{2}</span></span>|<span data-ttu-id="ef8a1-155">"al gerekli" (dizin 3)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="ef8a1-156">Olası eşleşme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-156">Possible match fails.</span></span>|  
|<span data-ttu-id="ef8a1-157">8</span><span class="sxs-lookup"><span data-stu-id="ef8a1-157">8</span></span>|<span data-ttu-id="ef8a1-158">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-158">e</span></span>|<span data-ttu-id="ef8a1-159">"al gerekli" (dizin 3)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-159">"ding a reed" (index 3)</span></span>|<span data-ttu-id="ef8a1-160">Eşleme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-160">Match fails.</span></span>|  
|<span data-ttu-id="ef8a1-161">9</span><span class="sxs-lookup"><span data-stu-id="ef8a1-161">9</span></span>|<span data-ttu-id="ef8a1-162">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-162">e</span></span>|<span data-ttu-id="ef8a1-163">"ing a reed" (dizin 4)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-163">"ing a reed" (index 4)</span></span>|<span data-ttu-id="ef8a1-164">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-164">No match.</span></span>|  
|<span data-ttu-id="ef8a1-165">10</span><span class="sxs-lookup"><span data-stu-id="ef8a1-165">10</span></span>|<span data-ttu-id="ef8a1-166">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-166">e</span></span>|<span data-ttu-id="ef8a1-167">"ng a reed" (dizin 5)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-167">"ng a reed" (index 5)</span></span>|<span data-ttu-id="ef8a1-168">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-168">No match.</span></span>|  
|<span data-ttu-id="ef8a1-169">11</span><span class="sxs-lookup"><span data-stu-id="ef8a1-169">11</span></span>|<span data-ttu-id="ef8a1-170">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-170">e</span></span>|<span data-ttu-id="ef8a1-171">"g a reed" (dizin 6)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-171">"g a reed" (index 6)</span></span>|<span data-ttu-id="ef8a1-172">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-172">No match.</span></span>|  
|<span data-ttu-id="ef8a1-173">12</span><span class="sxs-lookup"><span data-stu-id="ef8a1-173">12</span></span>|<span data-ttu-id="ef8a1-174">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-174">e</span></span>|<span data-ttu-id="ef8a1-175">"a reed" (dizin 7)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-175">" a reed" (index 7)</span></span>|<span data-ttu-id="ef8a1-176">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-176">No match.</span></span>|  
|<span data-ttu-id="ef8a1-177">13</span><span class="sxs-lookup"><span data-stu-id="ef8a1-177">13</span></span>|<span data-ttu-id="ef8a1-178">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-178">e</span></span>|<span data-ttu-id="ef8a1-179">"a reed" (dizin 8)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-179">"a reed" (index 8)</span></span>|<span data-ttu-id="ef8a1-180">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-180">No match.</span></span>|  
|<span data-ttu-id="ef8a1-181">14</span><span class="sxs-lookup"><span data-stu-id="ef8a1-181">14</span></span>|<span data-ttu-id="ef8a1-182">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-182">e</span></span>|<span data-ttu-id="ef8a1-183">"reed" (dizin 9)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-183">" reed" (index 9)</span></span>|<span data-ttu-id="ef8a1-184">Eşleşme yok.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-184">No match.</span></span>|  
|<span data-ttu-id="ef8a1-185">15</span><span class="sxs-lookup"><span data-stu-id="ef8a1-185">15</span></span>|<span data-ttu-id="ef8a1-186">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-186">e</span></span>|<span data-ttu-id="ef8a1-187">"reed" (dizin 10)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-187">"reed" (index 10)</span></span>|<span data-ttu-id="ef8a1-188">Eşleşme yok</span><span class="sxs-lookup"><span data-stu-id="ef8a1-188">No match</span></span>|  
|<span data-ttu-id="ef8a1-189">16</span><span class="sxs-lookup"><span data-stu-id="ef8a1-189">16</span></span>|<span data-ttu-id="ef8a1-190">e</span><span class="sxs-lookup"><span data-stu-id="ef8a1-190">e</span></span>|<span data-ttu-id="ef8a1-191">"eed" (dizin 11)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-191">"eed" (index 11)</span></span>|<span data-ttu-id="ef8a1-192">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-192">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-193">17</span><span class="sxs-lookup"><span data-stu-id="ef8a1-193">17</span></span>|<span data-ttu-id="ef8a1-194">E{2}</span><span class="sxs-lookup"><span data-stu-id="ef8a1-194">e{2}</span></span>|<span data-ttu-id="ef8a1-195">"ed" (dizin 12)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-195">"ed" (index 12)</span></span>|<span data-ttu-id="ef8a1-196">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-196">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-197">18</span><span class="sxs-lookup"><span data-stu-id="ef8a1-197">18</span></span>|<span data-ttu-id="ef8a1-198">\w</span><span class="sxs-lookup"><span data-stu-id="ef8a1-198">\w</span></span>|<span data-ttu-id="ef8a1-199">"d" (dizin 13)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-199">"d" (index 13)</span></span>|<span data-ttu-id="ef8a1-200">Olası eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-200">Possible match.</span></span>|  
|<span data-ttu-id="ef8a1-201">19</span><span class="sxs-lookup"><span data-stu-id="ef8a1-201">19</span></span>|<span data-ttu-id="ef8a1-202">\b</span><span class="sxs-lookup"><span data-stu-id="ef8a1-202">\b</span></span>|<span data-ttu-id="ef8a1-203">"" (dizin 14)</span><span class="sxs-lookup"><span data-stu-id="ef8a1-203">"" (index 14)</span></span>|<span data-ttu-id="ef8a1-204">Eşleşme.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-204">Match.</span></span>|  
  
 <span data-ttu-id="ef8a1-205">Bir normal ifade deseni isteğe bağlı miktar belirleyiciler veya değişim yapıları içermiyorsa, normal ifade desenini giriş dizesiyle eşleştirmek için gereken en fazla karşılaştırma sayısı, kabaca giriş dizesindeki karakter sayısına eşittir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-205">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="ef8a1-206">Bu durumda, normal ifade altyapısı, 13 karakterlik bu dizedeki olası eşleşmeleri tanımlamak için 19 karşılaştırma kullanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-206">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="ef8a1-207">Diğer bir deyişle, isteğe bağlı miktar belirleyiciler veya değişim yapıları içermiyorsa, normal ifade altyapısı doğrusala yakın bir zamanda çalışır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-207">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>  
  
 [<span data-ttu-id="ef8a1-208">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ef8a1-208">Back to top</span></span>](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="ef8a1-209">İsteğe Bağlı Miktar Belirleyiciler veya Değişim Yapıları ile Geri İzleme</span><span class="sxs-lookup"><span data-stu-id="ef8a1-209">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="ef8a1-210">Normal bir ifade isteğe bağlı miktar belirleyiciler veya değişim yapıları içerdiğinde, giriş dizesinin değerlendirilmesi artık doğrusal değildir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-210">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="ef8a1-211">Bir NFA altyapısıyla desen eşleştirme, giriş dizesinde eşleştirilecek karakterlerle değil, normal ifadedeki dil öğeleriyle yönlendirilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-211">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="ef8a1-212">Bu nedenle, normal ifade altyapısı, isteğe bağlı veya alternatif alt ifadeleri tam olarak eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-212">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="ef8a1-213">Alt ifadede sonraki dil öğesine ilerlediğinde ve eşleştirme başarısız olduğunda, normal ifade altyapısı, normal ifadeyi giriş dizesiyle bir bütün olarak eşleştirmek amacıyla, başarılı eşleştirmesinin bir bölümünü bırakır ve daha önce kaydedilen bir duruma geri döner.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-213">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="ef8a1-214">Bir eşleştirme bulmak üzere daha önce kaydedilen bir duruma bu şekilde geri dönme işlemi, geri izleme olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-214">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="ef8a1-215">Örneğin, normal ifade desenini düşünün `.*(es)`, "es" karakterleriyle ve tüm karakterleri, önünde bu.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-215">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="ef8a1-216">Aşağıdaki örnekte gösterildiği gibi, giriş dizesi "Essential services are provided by regular expressions." ise, desen, "expressions"daki "es"a kadar ve "es" dahil olmak üzere tüm dizeyle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-216">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="ef8a1-217">Bunu yapmak için, normal ifade altyapısı aşağıdaki gibi geri izlemeyi kullanır:</span><span class="sxs-lookup"><span data-stu-id="ef8a1-217">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
-   <span data-ttu-id="ef8a1-218">Eşleşecek `.*` (eşleşen sıfır, bir veya daha fazla tekrar herhangi bir karakterin) tüm giriş dizesiyle.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-218">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
-   <span data-ttu-id="ef8a1-219">Normal ifade deseninde "e"yi eşleştirmeyi dener.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-219">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="ef8a1-220">Ancak, giriş dizesinde eşleştirilebilecek başka karakter kalmamıştır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-220">However, the input string has no remaining characters available to match.</span></span>  
  
-   <span data-ttu-id="ef8a1-221">En son başarılı eşleştirmesi olan "Essential services are provided by regular expressions" dizesine geri izleme yapar ve "e"yi cümlenin sonundaki nokta ile eşleştirmeyi dener.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-221">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="ef8a1-222">Eşleştirme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-222">The match fails.</span></span>  
  
-   <span data-ttu-id="ef8a1-223">Geçici olarak eşleştirilen "Essential services are provided by regular expr" alt dizesine kadar, bir kerede bir karakter olacak şekilde, daha önceki başarılı bir eşleştirmeye geri izleme yapmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-223">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="ef8a1-224">Ardından, desendeki "e"yi "expressions"daki ikinci "e" ile karşılaştırır ve bir eşleştirme bulur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-224">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
-   <span data-ttu-id="ef8a1-225">Desendeki "s" ile, eşleştirilen "e" karakterini izleyen "s"yi ("expressions"daki ilk "s") karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-225">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="ef8a1-226">Eşleştirme başarılıdır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-226">The match is successful.</span></span>  
  
 <span data-ttu-id="ef8a1-227">Geri izleme kullandığınızda, normal ifade desenini 55 karakter uzunluğundaki giriş dizesiyle eşleştirmek, 67 karşılaştırma işlemi gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-227">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="ef8a1-228">Genellikle, normal bir ifade deseninin tek bir değişim yapısı veya tek bir isteğe bağlı miktar belirleyicisi varsa, deseni eşleştirmek için gereken karşılaştırma işlemlerinin sayısı, giriş dizesindeki karakterlerin sayısının iki katıdır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-228">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>  
  
 [<span data-ttu-id="ef8a1-229">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ef8a1-229">Back to top</span></span>](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="ef8a1-230">İç İçe Geçmiş İsteğe Bağlı Miktar Belirleyicilerle Geri İzleme</span><span class="sxs-lookup"><span data-stu-id="ef8a1-230">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="ef8a1-231">Desen çok sayıda değişim yapıları içeriyorsa, iç içe değişim yapıları içeriyorsa veya en yaygın olasılık olarak iç içe isteğe bağlı miktar belirleyiciler içeriyorsa, normal bir ifade desenini eşleştirmek için gereken karşılaştırma işlemlerinin sayısı katlanarak artabilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-231">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="ef8a1-232">Örneğin, normal ifade deseni `^(a+)+$` bir veya daha fazla "a" karakteri içeren tam bir dizeyle eşleştirme için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-232">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="ef8a1-233">Örnek, aynı uzunlukta iki giriş dizesi sağlar, fakat yalnızca ilk dize desenle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-233">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="ef8a1-234"><xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> Sınıfı, eşleştirme işleminin ne kadar süreceğini belirlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-234">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="ef8a1-235">Örnekteki çıktının gösterdiği gibi, normal ifade altyapısının, bir giriş dizesinin desenle eşleşmediğini bulması, eşleşen bir dize tanımlamasına göre iki kat daha uzun sürdü.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-235">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="ef8a1-236">Bunun nedeni, başarısız bir eşleştirmenin her zaman bir kötü durum senaryosunu temsil etmesidir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-236">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="ef8a1-237">Eşleştirmenin başarısız olduğu sonucuna varabilmesinden ve iç içe parantezlerin veri içinde birçok ek yol oluşturmasından önce, normal ifade altyapısının veri içinde olası tüm yolları izlemek için normal ifadeyi kullanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-237">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="ef8a1-238">Normal ifade altyapısı, aşağıdakileri yaparak ikinci dizenin desenle eşleşmediği sonucuna varır:</span><span class="sxs-lookup"><span data-stu-id="ef8a1-238">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
-   <span data-ttu-id="ef8a1-239">Dizenin başlangıcında olduğu ve ardından ilk beş eşleşme karakter dizesindeki deseni ile denetler `a+`.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-239">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="ef8a1-240">Ardından, dizede ek "a" karakteri grupları olmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-240">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="ef8a1-241">Son olarak, dizenin sonu için sınama yapar.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="ef8a1-242">Dizede bir ek karakter kaldığından, eşleştirme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="ef8a1-243">Bu hatalı eşleşme, 9 karşılaştırma gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-243">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="ef8a1-244">Normal ifade altyapısı ayrıca, "a" (eşleştirme 1 olarak adlandırırız), "aa" (eşleştirme 2), "aaa" (eşleştirme 3) ve "aaaa" (eşleştirme 4) eşleştirmelerinden elde ettiği durum bilgisini de kaydeder.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-244">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
-   <span data-ttu-id="ef8a1-245">Önceden kaydedilen eşleştirme 4'e döndürür.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-245">It returns to the previously saved match 4.</span></span> <span data-ttu-id="ef8a1-246">Ek bir yakalan gruba atamak için bir ek "a" karakteri olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-246">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="ef8a1-247">Son olarak, dizenin sonu için sınama yapar.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-247">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="ef8a1-248">Dizede bir ek karakter kaldığından, eşleştirme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-248">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="ef8a1-249">Bu hatalı eşleşme 4 karşılaştırma gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-249">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="ef8a1-250">Şu ana kadar toplam 13 karşılaştırma yapıldı.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-250">So far, a total of 13 comparisons have been performed.</span></span>  
  
-   <span data-ttu-id="ef8a1-251">Önceden kaydedilen eşleştirme 3 döndürür.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-251">It returns to the previously saved match 3.</span></span> <span data-ttu-id="ef8a1-252">Ek bir yakalanan gruba atamak için iki ek "a" karakteri olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-252">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="ef8a1-253">Ancak, dize sonu sınaması başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-253">However, the end-of-string test fails.</span></span> <span data-ttu-id="ef8a1-254">Ardından, eşleştirme 3'e geri döner ve yakalanan iki ek gruptaki iki ek "a" karakterini eşleştirmeyi dener.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-254">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="ef8a1-255">Dize sonu sınaması hala başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-255">The end-of-string test still fails.</span></span> <span data-ttu-id="ef8a1-256">Bu başarısız eşleştirmeler 12 karşılaştırma gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-256">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="ef8a1-257">Şu ana kadar toplam 25 karşılaştırma yapıldı.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-257">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="ef8a1-258">Giriş dizesinin normal ifadeyle karşılaştırılması, normal ifade altyapısı tüm olası eşleştirme birleşimlerini deneyinceye kadar bu şekilde devam eder ve ardından eşleştirme olmadığı sonucuna ulaşır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-258">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="ef8a1-259">İç içe geçmiş miktar belirleyiciler yüzünden, bu karşılaştırma bir O olduğu (2<sup>n</sup>) veya bir üstel işlemdir; burada *n* giriş dizesindeki karakterlerin sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-259">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="ef8a1-260">Bu, en kötü durumda, 30 karakterlik bir giriş dizesinin yaklaşık 1.073.741.824 karşılaştırma gerektirdiği ve 40 karakterlik bir giriş dizesinin yaklaşık 1,099,511,627,776 karşılaştırma gerektirdiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-260">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="ef8a1-261">Bu uzunluklarda veya daha uzun dizeler kullanırsanız, normal ifade deseniyle eşleşmeyen giriş işlediklerinde, normal ifade yöntemlerinin tamamlanması çok uzun zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-261">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>  
  
 [<span data-ttu-id="ef8a1-262">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ef8a1-262">Back to top</span></span>](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a><span data-ttu-id="ef8a1-263">Geri İzlemeyi Denetleme</span><span class="sxs-lookup"><span data-stu-id="ef8a1-263">Controlling Backtracking</span></span>  
 <span data-ttu-id="ef8a1-264">Geri izleme, güçlü ve esnek normal ifadeler oluşturmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-264">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="ef8a1-265">Ancak, önceki bölümde gösterildiği gibi, bu yararlar kabuk edilemeyecek kadar düşük performansla eşleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-265">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="ef8a1-266">Başlattığınızda aşırı geri izleme yapılmasını önlemek için bir zaman aşımı aralığı tanımlamanız bir <xref:System.Text.RegularExpressions.Regex> nesne veya statik bir normal ifade eşleştirme yöntemi çağırın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-266">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="ef8a1-267">Bu konu, sonraki bölümde açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-267">This is discussed in the next section.</span></span> <span data-ttu-id="ef8a1-268">Ayrıca, .NET, veya ve karmaşık normal ifadeleri çok az kayıpla veya hiç performans cezası ile destekleyen üç normal ifade dil öğesini destekler: [geri dönüşlü olmayan alt ifadeler](#Nonbacktracking), [geriye yönelik onaylar](#Lookbehind), ve [ileriye yönelik onaylar](#Lookahead).</span><span class="sxs-lookup"><span data-stu-id="ef8a1-268">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [nonbacktracking subexpressions](#Nonbacktracking), [lookbehind assertions](#Lookbehind), and [lookahead assertions](#Lookahead).</span></span> <span data-ttu-id="ef8a1-269">Her dil öğesi hakkında daha fazla bilgi için bkz: [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ef8a1-269">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a><span data-ttu-id="ef8a1-270">Bir Zaman Aşımı Aralığı Tanımlama</span><span class="sxs-lookup"><span data-stu-id="ef8a1-270">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="ef8a1-271">İle başlayarak [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], normal ifade altyapısının, denemeden Vazgeçmeden ve önce tek bir eşleştirme için arama yapacağı en uzun aralığı gösteren bir zaman aşımı değeri ayarlayabilirsiniz bir <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> özel durum.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-271">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="ef8a1-272">Sağlayarak zaman aşımı aralığı belirttiğiniz bir <xref:System.TimeSpan> değerini <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> örnek normal ifadeler için oluşturucu.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-272">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="ef8a1-273">Ayrıca, her bir statik desen eşleştirme yönteminin bir aşırı yüklemesi vardır bir <xref:System.TimeSpan> parametresi bir zaman aşımı değeri belirtmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-273">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="ef8a1-274">Varsayılan olarak, zaman aşımı aralığı ayarlamak <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ve normal ifade altyapısı zaman aşımına uğramaz.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-274">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ef8a1-275">Normal ifadeniz geri izlemeye dayalıysa, her zaman bir zaman aşımı aralığı ayarlamanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-275">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="ef8a1-276">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> özel durum gösterir ve normal ifade altyapısının belirtilen zaman aşımı aralığı içinde bir eşleştirme bulamadığını ancak özel durumun neden anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-276">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="ef8a1-277">Bunun nedeni aşırı geri izleme olabilir, fakat özel durumun oluştuğu zamandaki sistem yükü nedeniyle zaman aşımı aralığı çok düşük ayarlanmış da olabilir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-277">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="ef8a1-278">Özel durumu işlediğinizde, giriş dizesiyle diğer eşleştirmeleri bırakmayı veya zaman aşımı aralığını artırarak eşleştirme işlemini yeniden denemeyi seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-278">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="ef8a1-279">Örneğin, aşağıdaki çağrıları kod <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> örneği oluşturmak için oluşturucu bir <xref:System.Text.RegularExpressions.Regex> bir saniyelik zaman aşımı değerini içeren nesne.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-279">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="ef8a1-280">Normal ifade deseni `(a+)+$`, bir veya daha fazla "a" karakteri bir satırın sonunda bir veya daha fazla dizileri eşleşen olduğu aşırı geri izlemeye maruz kalır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-280">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="ef8a1-281">Varsa bir <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> olduğu durum, örnek en fazla üç saniye cinsinden zaman aşımı değerini artırır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-281">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="ef8a1-282">Bundan sonra, deseni eşleştirme girişiminden vazgeçer.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-282">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a><span data-ttu-id="ef8a1-283">Geri İzlemeli Olmayan Alt İfade</span><span class="sxs-lookup"><span data-stu-id="ef8a1-283">Nonbacktracking Subexpression</span></span>  
 <span data-ttu-id="ef8a1-284">`(?>` *Subexpression* `)` dil öğesi bir alt ifadede geri izlemeyi bastırır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-284">The `(?>` *subexpression*`)` language element suppresses backtracking in a subexpression.</span></span> <span data-ttu-id="ef8a1-285">Başarısız eşleştirmelerle ilişkili performans sorunlarını önlemek için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-285">It is useful for preventing the performance problems associated with failed matches.</span></span>  
  
 <span data-ttu-id="ef8a1-286">Aşağıdaki örnekte, iç içe miktar belirleyiciler kullanılırken geri izlemenin bastırılmasının performansı nasıl iyileştirdiği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-286">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="ef8a1-287">Normal ifade altyapısının bir giriş dizesinin iki normal ifadeyle eşleşmediğini belirlemesi için gereken süreyi ölçer.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-287">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="ef8a1-288">İlk normal ifade, ardından bir iki nokta işareti, ardından bir veya daha fazla ondalık basamak, ardından iki iki nokta işareti gelen bir veya birden fazla ondalık basamağın bir veya birden fazla örneğini içeren bir dizeyle eşleştirme yapmayı denemek için geri izleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-288">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="ef8a1-289">İkinci normal ifade, geri izlemeyi devre dışı bırakması dışında, birincisiyle aynıdır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-289">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="ef8a1-290">Örnekteki çıktının gösterdiği gibi, geri izlemeyi devre dışı bırakmanın sağladığı performans iyileşmesi önemlidir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-290">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a><span data-ttu-id="ef8a1-291">Geriye Yönelik Onaylar</span><span class="sxs-lookup"><span data-stu-id="ef8a1-291">Lookbehind Assertions</span></span>  
 <span data-ttu-id="ef8a1-292">.NET içeren iki dil öğesi `(?<=` *subexpression* `)` ve `(?<!` *subexpression*`)`, önceki karakterle veya karakterlerle eşleşen Giriş dizesi.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-292">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="ef8a1-293">Her iki dil öğesi de sıfır genişlikli onaylardır; diğer bir deyişle, bunlar geçerli karakter hemen önce gelen karakterin veya eşleştirilip olup olmadığını belirlemek *subexpression*karakterlerin ilerlemeden veya geri izleme yapmadan.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-293">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="ef8a1-294">`(?<=` *alt ifade* `)` bir pozitif geriye yönelik onaydır; yani karakteri veya karakterleri geçerli konumu eşleşmelidir önce olduğundan *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-294">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="ef8a1-295">`(?<!`*alt ifade* `)` bir negatif geriye yönelik onaydır; yani karakteri veya karakterleri geçerli konumu eşleşmemelidir önce olduğundan *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-295">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="ef8a1-296">Her iki pozitif ve negatif geriye yönelik onaylar olduğunda en kullanışlı *subexpression* önceki alt ifade bir alt kümesidir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-296">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="ef8a1-297">Aşağıdaki örnek, bir e-posta adresi kullanıcı adını doğrulayan iki denk normal ifade deseni kullanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-297">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="ef8a1-298">Birinci desen, aşırı geri izleme nedeniyle yetersiz performansa maruz kalır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-298">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="ef8a1-299">İkinci desen, iç içe bir miktar belirleyiciyi pozitif bir geriye yönelik onayla değiştirerek birinci normal ifadeyi değiştirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-299">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="ef8a1-300">Örnekteki çıktının yürütme zamanını görüntüler <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-300">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="ef8a1-301">Birinci normal ifade deseni `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, aşağıdaki tabloda gösterildiği gibi tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-301">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ef8a1-302">Desen</span><span class="sxs-lookup"><span data-stu-id="ef8a1-302">Pattern</span></span>|<span data-ttu-id="ef8a1-303">Açıklama</span><span class="sxs-lookup"><span data-stu-id="ef8a1-303">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="ef8a1-304">Eşleştirmeyi dizenin başlangıcında başlatın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-304">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="ef8a1-305">Alfasayısal bir karakterle eşleştirin</span><span class="sxs-lookup"><span data-stu-id="ef8a1-305">Match an alphanumeric character.</span></span> <span data-ttu-id="ef8a1-306">Bu karşılaştırma büyük/küçük harfe, çünkü <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> yöntemi çağrıldığında <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> seçeneği.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-306">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="ef8a1-307">Bir kısa çizgi, nokta veya sözcük karakterinin sıfır, bir veya daha fazla örneğini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-307">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="ef8a1-308">Alfasayısal bir karakterle eşleştirin</span><span class="sxs-lookup"><span data-stu-id="ef8a1-308">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="ef8a1-309">Ardından alfasayısal bir karakter gelen sıfır veya daha fazla kısa çizgi, nokta veya sözcük karakteri birleşiminin sıfır veya daha fazla örneğini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-309">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="ef8a1-310">Bu ilk yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-310">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="ef8a1-311">Eşleşme bir at işareti ("\@").</span><span class="sxs-lookup"><span data-stu-id="ef8a1-311">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="ef8a1-312">İkinci normal ifade deseni `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, pozitif bir geriye yönelik onay kullanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-312">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="ef8a1-313">Aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-313">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ef8a1-314">Desen</span><span class="sxs-lookup"><span data-stu-id="ef8a1-314">Pattern</span></span>|<span data-ttu-id="ef8a1-315">Açıklama</span><span class="sxs-lookup"><span data-stu-id="ef8a1-315">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="ef8a1-316">Eşleştirmeyi dizenin başlangıcında başlatın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-316">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="ef8a1-317">Alfasayısal bir karakterle eşleştirin</span><span class="sxs-lookup"><span data-stu-id="ef8a1-317">Match an alphanumeric character.</span></span> <span data-ttu-id="ef8a1-318">Bu karşılaştırma büyük/küçük harfe, çünkü <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> yöntemi çağrıldığında <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> seçeneği.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-318">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="ef8a1-319">Bir kısa çizgi, nokta veya sözcük karakterinin sıfır, bir veya daha fazla örneğini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-319">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="ef8a1-320">Son eşleşen karaktere geriye doğru bakın ve alfasayısal ise eşleştirmeyi devam ettirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-320">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="ef8a1-321">Alfasayısal karakterlerin, nokta, kısa çizgi ve tüm sözcük karakterlerinden oluşan kümenin bir alt kümesi olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-321">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="ef8a1-322">Eşleşme bir at işareti ("\@").</span><span class="sxs-lookup"><span data-stu-id="ef8a1-322">Match an at sign ("\@").</span></span>|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a><span data-ttu-id="ef8a1-323">İleriye Yönelik Onaylar</span><span class="sxs-lookup"><span data-stu-id="ef8a1-323">Lookahead Assertions</span></span>  
 <span data-ttu-id="ef8a1-324">.NET içeren iki dil öğesi `(?=` *subexpression* `)` ve `(?!` *subexpression*`)`, sonraki karakterle veya karakterlerle eşleşen Giriş dizesi.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-324">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="ef8a1-325">Her iki dil öğesi de sıfır genişlikli onaylardır; diğer bir deyişle, bunlar geçerli karakterden hemen izleyen karakterin veya eşleştirilip olup olmadığını belirlemek *subexpression*karakterlerin ilerlemeden veya geri izleme yapmadan.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-325">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="ef8a1-326">`(?=` *alt ifade* `)` geçerli konumu eşleşmelidir sonra bir pozitif ileriye yönelik onaydır; yani karakterin veya karakter olduğu *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-326">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="ef8a1-327">`(?!`*alt ifade* `)` geçerli konumu eşleşmemelidir sonra bir negatif ileriye yönelik onaydır; yani karakterin veya karakter olduğu *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-327">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="ef8a1-328">Her iki pozitif ve negatif ileriye yönelik onaylar olduğunda en kullanışlı *subexpression* sonraki alt ifade bir alt kümesidir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-328">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="ef8a1-329">Aşağıdaki örnekte, tam olarak belirtilen bir tür adını doğrulayan iki denk normal ifade deseni kullanılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-329">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="ef8a1-330">Birinci desen, aşırı geri izleme nedeniyle yetersiz performansa maruz kalır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-330">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="ef8a1-331">İkincisi, iç içe bir miktar belirleyiciyi pozitif bir ileriye yönelik onayla değiştirerek birinci normal ifadeyi değiştirir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-331">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="ef8a1-332">Örnekteki çıktının yürütme zamanını görüntüler <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-332">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="ef8a1-333">Birinci normal ifade deseni `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, aşağıdaki tabloda gösterildiği gibi tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-333">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ef8a1-334">Desen</span><span class="sxs-lookup"><span data-stu-id="ef8a1-334">Pattern</span></span>|<span data-ttu-id="ef8a1-335">Açıklama</span><span class="sxs-lookup"><span data-stu-id="ef8a1-335">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="ef8a1-336">Eşleştirmeyi dizenin başlangıcında başlatın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-336">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="ef8a1-337">Ardından bir nokta gelen sıfır veya daha fazla sözcük karakterinin bir veya birden çok kez ardından geldiği bir alfabetik karakterle (A-Z) eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-337">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="ef8a1-338">Bu karşılaştırma büyük/küçük harfe, çünkü <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> yöntemi çağrıldığında <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> seçeneği.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-338">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="ef8a1-339">Önceki desenle sıfır veya daha çok kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-339">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="ef8a1-340">Ardından sıfır veya daha fazla karakter gelen alfabetik bir karakterle eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-340">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="ef8a1-341">Giriş dizesinin sonunda eşleşmeyi bitir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-341">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="ef8a1-342">İkinci normal ifade deseni `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, pozitif bir ileriye yönelik onay kullanır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-342">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="ef8a1-343">Aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-343">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ef8a1-344">Desen</span><span class="sxs-lookup"><span data-stu-id="ef8a1-344">Pattern</span></span>|<span data-ttu-id="ef8a1-345">Açıklama</span><span class="sxs-lookup"><span data-stu-id="ef8a1-345">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="ef8a1-346">Eşleştirmeyi dizenin başlangıcında başlatın.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-346">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="ef8a1-347">İleriye yönelik olarak birinci karaktere bakın ve alfabetik (A-Z) ise eşleştirmeyi devam ettirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-347">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="ef8a1-348">Bu karşılaştırma büyük/küçük harfe, çünkü <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> yöntemi çağrıldığında <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> seçeneği.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-348">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="ef8a1-349">Ardından bir nokta gelen bir veya daha fazla sözcük karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-349">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="ef8a1-350">Ardından sıfır veya daha çok kez bir nokta gelen bir veya birden çok sözcük karakteri desenini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-350">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="ef8a1-351">İlk sözcük karakterinin alfabetik olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-351">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="ef8a1-352">Ardından sıfır veya daha fazla karakter gelen alfabetik bir karakterle eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-352">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="ef8a1-353">Giriş dizesinin sonunda eşleşmeyi bitir.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-353">End the match at the end of the input string.</span></span>|  
  
 [<span data-ttu-id="ef8a1-354">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ef8a1-354">Back to top</span></span>](#top)  
  
## <a name="see-also"></a><span data-ttu-id="ef8a1-355">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="ef8a1-355">See also</span></span>

- [<span data-ttu-id="ef8a1-356">.NET normal ifadeler</span><span class="sxs-lookup"><span data-stu-id="ef8a1-356">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)  
- [<span data-ttu-id="ef8a1-357">Normal İfade Dili - Hızlı Başvuru</span><span class="sxs-lookup"><span data-stu-id="ef8a1-357">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
- [<span data-ttu-id="ef8a1-358">Belirleyiciler</span><span class="sxs-lookup"><span data-stu-id="ef8a1-358">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)  
- [<span data-ttu-id="ef8a1-359">Değişim Yapıları</span><span class="sxs-lookup"><span data-stu-id="ef8a1-359">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)  
- [<span data-ttu-id="ef8a1-360">Gruplama Yapıları</span><span class="sxs-lookup"><span data-stu-id="ef8a1-360">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
