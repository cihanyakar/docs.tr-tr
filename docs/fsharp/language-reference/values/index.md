---
title: Değerler (F#)
description: 'F # değerleri belirli bir tür olan miktarlar nasıl olduğunu öğrenin.'
ms.date: 05/16/2016
ms.openlocfilehash: f645481ce8395c11ae920aee06cbf07955aeb684
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/02/2018
ms.locfileid: "45991174"
---
# <a name="values"></a><span data-ttu-id="fd263-103">Değerler</span><span class="sxs-lookup"><span data-stu-id="fd263-103">Values</span></span>

<span data-ttu-id="fd263-104">Belirli bir tür olan miktarlar değerler F #; değerleri tamsayı veya kayan nokta numaralarını, karakter veya metin, listeler, dizileri, diziler, diziler, ayrılmış birleşimler, kayıtları, sınıf türleri veya işlev değerleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd263-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="fd263-105">Bir değer bağlama</span><span class="sxs-lookup"><span data-stu-id="fd263-105">Binding a Value</span></span>

<span data-ttu-id="fd263-106">Terim *bağlama* bir adı bir tanımı ile ilişkilendirme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="fd263-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="fd263-107">`let` Anahtar sözcüğü, aşağıdaki örneklerde gösterildiği gibi bir değere bağlar:</span><span class="sxs-lookup"><span data-stu-id="fd263-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="fd263-108">Bir değer türü tanımından algılanır.</span><span class="sxs-lookup"><span data-stu-id="fd263-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="fd263-109">Bir tamsayı veya kayan noktalı sayı gibi basit bir tür için tür sabit değerinin türü belirlenir.</span><span class="sxs-lookup"><span data-stu-id="fd263-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="fd263-110">Bu nedenle, önceki örnekte, derleyicinin türünü çıkarsar `b` olmasını `unsigned int`derleyici türünü çıkarsar bilgileriyse `a` olmasını `int`.</span><span class="sxs-lookup"><span data-stu-id="fd263-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="fd263-111">Bir işlevi değer türü, işlev gövdesinde dönüş değerinden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="fd263-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="fd263-112">İşlev değer türleri hakkında daha fazla bilgi için bkz: [işlevleri](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="fd263-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="fd263-113">Değişmez değer türleri hakkında daha fazla bilgi için bkz: [değişmez değerleri](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="fd263-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="fd263-114">Derleyici, varsayılan olarak kullanılmayan bağlamalar hakkında tanılama kesmez.</span><span class="sxs-lookup"><span data-stu-id="fd263-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="fd263-115">Bu iletileri almayı etkinleştirme derleyici çağrılırken 1182 proje dosyanızdaki veya uyarı (bkz `--warnon` altında [derleyici seçenekleri](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="fd263-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="fd263-116">Sabit neden?</span><span class="sxs-lookup"><span data-stu-id="fd263-116">Why Immutable?</span></span>

<span data-ttu-id="fd263-117">Değişmez değerler, program yürütme kurs değiştirilemez değerlerdir.</span><span class="sxs-lookup"><span data-stu-id="fd263-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="fd263-118">C++, Visual Basic veya C# gibi diller için kullanılıyorsa, F # primacy bir programın yürütülmesi sırasında yeni değerler atanabilir değişkenler yerine sabit değerler üzerinden geçirir, şaşırtıcı bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd263-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="fd263-119">Sabit veri, işlevsel programlama, önemli bir öğesidir.</span><span class="sxs-lookup"><span data-stu-id="fd263-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="fd263-120">Çok iş parçacıklı bir ortamda yönetmek birçok farklı iş parçacıkları tarafından değiştirilebilecek paylaşılan değişebilir değişkenleri zordur.</span><span class="sxs-lookup"><span data-stu-id="fd263-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="fd263-121">Ayrıca, değişebilir değişkenleri ile bazen bir değişken başka bir işleve geçirildiğinde değiştirilebilir, bildirmek zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd263-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="fd263-122">Saf işlevsel dillerde, değişken yok ve İşlevler, kesinlikle matematiksel işlevler olarak davranır.</span><span class="sxs-lookup"><span data-stu-id="fd263-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="fd263-123">Yordam bir dilde kod, bir değeri değiştirmek için değişken ataması kullanır. Burada, işlevsel bir dildir eşdeğer kodda giriş ve sabit bir işlevi farklı değişmez değerler çıktı olarak bir sabit değer var.</span><span class="sxs-lookup"><span data-stu-id="fd263-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="fd263-124">Bu matematiksel katılık programın davranışını hakkında akıl sıkı sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd263-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="fd263-125">Ne derleyicileri daha kesin kodunu kontrol edin ve daha etkili bir şekilde en iyi duruma getirmeyi sağlayan sıkı bu mantık, ve geliştiricilerin anlamak ve doğru kod yazmak için kolaylaştırmak yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="fd263-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="fd263-126">Bu nedenle işlev kodu sıradan yordam kodda hata ayıklamak daha kolay olacak şekilde olasıdır.</span><span class="sxs-lookup"><span data-stu-id="fd263-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="fd263-127">F # saf işlevsel bir dil değil henüz tam olarak işlevsel programlama destekler.</span><span class="sxs-lookup"><span data-stu-id="fd263-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="fd263-128">Bunun yapılması bir önemli işlevsel programlama açısından yararlanmak kodunuzu izin verdiğinden değişmez değerleri kullanılarak iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="fd263-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="fd263-129">Değişebilir değişkenleri</span><span class="sxs-lookup"><span data-stu-id="fd263-129">Mutable Variables</span></span>

<span data-ttu-id="fd263-130">Anahtar sözcüğünü kullanabilirsiniz `mutable` değiştirilebilen bir bağımsız değişken belirtin.</span><span class="sxs-lookup"><span data-stu-id="fd263-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="fd263-131">F # değişebilir değişkenleri genel olarak, bir türün bir alanı veya yerel bir değer olarak bir sınırlı kapsamı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd263-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="fd263-132">Kısıtlı bir kapsamla değişebilir değişkenleri denetlemek için daha kolay ve yanlış şekilde değiştirilmesi olasılığı daha düşüktür.</span><span class="sxs-lookup"><span data-stu-id="fd263-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="fd263-133">Kullanarak bir başlangıç değeri değişebilir bir değişkene atayabilirsiniz `let` aynı şekilde bir değer tanımlayacağınız anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="fd263-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="fd263-134">Ancak, daha sonra yeni değerleri değişebilir değişkenleri kullanarak atayabilirsiniz olduğunu fark `<-` işleci, aşağıdaki örnekte olduğu gibi.</span><span class="sxs-lookup"><span data-stu-id="fd263-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="fd263-135">İşaretli değerleri `mutable` için otomatik olarak yükseltilebilir `'a ref` kapanım tarafından yakalanan, kapanışları, gibi oluşturan formlar dahil `seq` oluşturucular.</span><span class="sxs-lookup"><span data-stu-id="fd263-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="fd263-136">Bu gerçekleştiğinde bildirim almak istiyorsanız, uyarı etkinleştirin 3180 proje dosyanızdaki veya derleyicisini çağırma.</span><span class="sxs-lookup"><span data-stu-id="fd263-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="fd263-137">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="fd263-137">Related Topics</span></span>

|<span data-ttu-id="fd263-138">Başlık</span><span class="sxs-lookup"><span data-stu-id="fd263-138">Title</span></span>|<span data-ttu-id="fd263-139">Açıklama</span><span class="sxs-lookup"><span data-stu-id="fd263-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="fd263-140">let Bağlamaları</span><span class="sxs-lookup"><span data-stu-id="fd263-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="fd263-141">Kullanma hakkında bilgi sağlar `let` adlarını değerleri ve işlevlere bağlamak için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="fd263-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="fd263-142">İşlevler</span><span class="sxs-lookup"><span data-stu-id="fd263-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="fd263-143">F # işlevleri'ne genel bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd263-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="fd263-144">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="fd263-144">See also</span></span>

- [<span data-ttu-id="fd263-145">Null Değerler</span><span class="sxs-lookup"><span data-stu-id="fd263-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="fd263-146">F# Dili Başvurusu</span><span class="sxs-lookup"><span data-stu-id="fd263-146">F# Language Reference</span></span>](../index.md)
